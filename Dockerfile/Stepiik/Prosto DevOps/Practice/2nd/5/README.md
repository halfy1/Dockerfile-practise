Используем ARG и USER в Alpine для обработки текстовых файлов
Предположим, вы пишете небольшой инструмент, который считывает текстовые файлы из /data и обрабатывает их скриптом process.sh. Вы хотите иметь гибкость в выборе пакета для обработки текста, а также запускать контейнер от лица обычного пользователя, а не root.

Техническое задание (ТЗ)
Базовый образ — alpine:3.17.
ARG ARG TEXT_TOOL=grep: Использовать эту переменную, чтобы установить нужный пакет. По умолчанию TEXT_TOOL=grep, но можно заменить на sed, awk и т. д.
Например, если TEXT_TOOL=grep, то в контейнере устанавливаем grep.
Если TEXT_TOOL=sed, то ставим sed.
Используйте RUN apk add --no-cache $TEXT_TOOL или любую другую логику.

Создать пользователя myuser, который не имеет прав root.
USER myuser: переключиться на этого пользователя.
Обозначить рабочую директорию /home/myuser/app (соответственно, папка должна принадлежать myuser).
Скопировать файл process.sh (и сделать его исполняемым) в папку приложения. Внутри process.sh вы можете обращаться к переменной TEXT_TOOL (как $TEXT_TOOL) или просто запускать установленную утилиту.
В качестве примера: ./process.sh /data/somefile.txt ищет, например, строки, содержащие «ERROR» (через grep), или модифицирует текст (через sed).
VOLUME /data: объявите директорию, откуда будет читаться входной файл. При запуске контейнера вы сможете подмонтировать локальную папку в /data.
CMD — пусть запускает ["/home/myuser/app/process.sh", "/data/input.txt"]. В результате при запуске контейнера без аргументов будет обрабатываться файл /data/input.txt.
Итог: При сборке можно указывать пакет (grep, sed и т. д.) флагом --build-arg TEXT_TOOL=sed. При запуске контейнера (например, с монтированием локальной папки /local_data в /data), ваш скрипт process.sh под пользователем myuser обрабатывает файл /data/input.txt выбранным инструментом